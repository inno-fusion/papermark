NEXTAUTH_SECRET=my-superstrong-secret
NEXTAUTH_URL=http://localhost:3000

NEXT_PUBLIC_BASE_URL=http://localhost:3000
NEXT_PUBLIC_MARKETING_URL=http://localhost:3000

NEXT_PUBLIC_APP_BASE_HOST=localhost

# [[SELF-HOSTING MODE]]
# Set to "1" to enable self-hosted mode with unlimited features
# This removes all plan limits (documents, links, users, datarooms, etc.)
NEXT_PUBLIC_SELFHOSTED=1

# Default domain for links (used in self-hosted mode)
# Change this to your own domain (e.g., "docs.yourcompany.com")
NEXT_PUBLIC_APP_DOMAIN=papermark.com

# Set to "true" or "1" to disable new user signups
# Existing users can still log in
# NEXT_PUBLIC_DISABLE_SIGNUP=false

# These variables are from Vercel Storage Postgres
POSTGRES_PRISMA_URL=
POSTGRES_PRISMA_URL_NON_POOLING=
# This variable is from Vercel Storage Blob
BLOB_READ_WRITE_TOKEN=

# Google client id and secret for authentication
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=

# [[EMAIL CONFIGURATION]]
# Choose ONE provider: SMTP (for self-hosting) or Resend (cloud service)
# SMTP takes priority if both are configured

# OPTION 1: SMTP (Recommended for self-hosting)
# Works with AWS SES, OCI Email, or any SMTP server
# AWS SES: smtp.us-east-1.amazonaws.com
# OCI Email: smtp.email.ap-mumbai-1.oci.oraclecloud.com
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASSWORD=
# Set to "false" to skip TLS certificate verification (not recommended for production)
# SMTP_TLS_REJECT_UNAUTHORIZED=true

# OPTION 2: Resend (Cloud email service)
RESEND_API_KEY=

# Email sender addresses (used by both providers)
EMAIL_FROM=Papermark <noreply@yourdomain.com>
# EMAIL_FROM_MARKETING=Marketing <marketing@yourdomain.com>
# EMAIL_FROM_SYSTEM=Papermark <system@yourdomain.com>
# EMAIL_FROM_VERIFY=Papermark <verify@yourdomain.com>
# EMAIL_TEST_ADDRESS=test@yourdomain.com

# These variables are from Vercel and used for setting up custom domains
PROJECT_ID_VERCEL=
TEAM_ID_VERCEL=
AUTH_BEARER_TOKEN=

# [[QSTASH - OPTIONAL]]
# Only needed for Vercel deployments using QStash for cron job scheduling.
# For self-hosted setups, cron routes can be triggered by any scheduler.
# Webhook delivery now uses BullMQ workers (no QStash required).
# QSTASH_TOKEN=
# QSTASH_CURRENT_SIGNING_KEY=
# QSTASH_NEXT_SIGNING_KEY=

# Redis for BullMQ job queues (required for background jobs)
# Use your own Redis instance or docker-compose up redis
REDIS_URL=redis://localhost:6379

# [[STORAGE]]
# Defines the storage transport to use. Available options: vercel (default) | s3
NEXT_PUBLIC_UPLOAD_TRANSPORT="vercel"
# REQUIRED: Defines the distribution host (without protocol) to use for the storage transport. Either cloudfront, s3, or vercel blob host. Used in next.config.mjs configuration.
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_HOST="<BLOB_STORE_ID>.public.blob.vercel-storage.com" | "<DISTRIBUTION_ID>.cloudfront.net" | "<BUCKET_NAME>.s3.<REGION>.amazonaws.com"
# OPTIONAL: Defines the endpoint to use for the S3 storage transport. Relevant when using third-party S3-compatible providers.
NEXT_PRIVATE_UPLOAD_ENDPOINT=""
# Defines the region to use for the S3 storage transport. Defaults to us-east-1.
NEXT_PRIVATE_UPLOAD_REGION="us-east-1"
# REQUIRED: Defines the bucket to use for the S3 storage transport.
NEXT_PRIVATE_UPLOAD_BUCKET="YOUR_BUCKET_NAME"
# REQUIRED: Defines the access key ID to use for the S3 storage transport.
NEXT_PRIVATE_UPLOAD_ACCESS_KEY_ID=""
# REQUIRED: Defines the secret access key to use for the S3 storage transport.
NEXT_PRIVATE_UPLOAD_SECRET_ACCESS_KEY=""
# Defines the Cloudfront distribution domain to use for the S3 storage transport. Relevant when using Cloudfront.
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_DOMAIN=""
# Defines the public key ID to sign Cloudfront URLs. Relevant when using Cloudfront.
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_KEY_ID=""
# Defines the private key contents to sign Cloudfront URLs. Relevant when using Cloudfront. Should be a PEM-encoded RSA 2048 private key.
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_KEY_CONTENTS=

# Encryption key for document passwords.
NEXT_PRIVATE_DOCUMENT_PASSWORD_KEY=my-superstrong-document-secret

# Internal API key for server-to-server communication (required for workers)
# Generate a random string: openssl rand -hex 32
INTERNAL_API_KEY=your-internal-api-key-here

# [[DOCUMENT CONVERSION]]
# Gotenberg for LibreOffice conversion (Office docs â†’ PDF)
# Run: docker-compose up gotenberg
NEXT_PRIVATE_CONVERSION_BASE_URL=http://localhost:3001
NEXT_PRIVATE_INTERNAL_AUTH_TOKEN=

# CloudConvert API for CAD/Keynote files (optional)
NEXT_PRIVATE_CONVERT_API_URL=
NEXT_PRIVATE_CONVERT_API_KEY=

# [[REDIS LOCKER CONFIGURATION]]
# For bulk upload using tus.io, we use a Redis-based locker to prevent corruption of the data.
UPSTASH_REDIS_REST_LOCKER_URL=
UPSTASH_REDIS_REST_LOCKER_TOKEN=

# [[VERIFICATION]]
# Secret used to generate the checksum for the verification URL
NEXT_PRIVATE_VERIFICATION_SECRET=

# [[INCOMING WEBHOOKS]]
NEXT_PUBLIC_WEBHOOK_BASE_URL=
NEXT_PUBLIC_WEBHOOK_BASE_HOST=

# [[SLACK INTEGRATION]]
# Create a Slack app at https://api.slack.com/apps
# Configure OAuth redirect: {BASE_URL}/api/integrations/slack/oauth/callback
# Required scopes: channels:read, chat:write, chat:write.public, groups:read, team:read, users:read
SLACK_CLIENT_ID=
SLACK_CLIENT_SECRET=
SLACK_APP_INSTALL_URL=https://slack.com/oauth/v2/authorize?client_id=YOUR_CLIENT_ID&scope=channels:read,chat:write,chat:write.public,groups:read,team:read,users:read
# Fixed ID - same across all instances. Run: npx tsx prisma/seed-slack.ts to seed the database
SLACK_INTEGRATION_ID=clslackintegration0x
# Encryption key for Slack tokens (generate: openssl rand -hex 32)
NEXT_PRIVATE_SLACK_ENCRYPTION_KEY=
